/*
   Simple abductive meta-interpreter with
   event calculus axioms, as presented in
   Cognitive Robotics course notes
   Uses depth-first search strategy
*/


:- use_module(library(lists)).


abdemo([],R,R,N,N).
/*
abdemo(Gs,R1,R2,Ns1,Ns2) :-
     write(Gs), nl, nl,
     write(R1), nl, nl,
     write(Ns1), nl, nl,
     read_line(C), nl, fail.
*/

abdemo([holds(F,T)|Gs1],R1,R4,Ns1,Ns4) :-
	write('abdemo 1.1'), nl, nl,
     resolve(initially(F),R1,Gs2,R2,[]),
	write('abdemo 1.2'), nl, nl,
     resolve(not(clipped(0,F,T)),R2,[],R2,Ns2),
	write('abdemo 1.3'), nl, nl,
     append(Ns1,Ns2,Ns3),
	write('abdemo 1.4'), nl, nl,
     abdemo_nafs(Ns3,R2,R3),
	write('abdemo 1.5'), nl, nl,
     append(Gs2,Gs1,Gs3),
	write('abdemo 1.6'), nl, nl,
     abdemo(Gs3,R3,R4,Ns3,Ns4).

abdemo([holds(F,T2)|Gs1],R1,R5,Ns1,Ns4) :-
     !, resolve(initiates(A,F,T1),R1,Gs2,R1,[]),
     resolve(happens(A,T1),R1,[],R2,[]),
     resolve(before(T1,T2),R2,[],R3,[]),
     resolve(not(clipped(T1,F,T2)),R3,[],R3,Ns2),
     append(Ns1,Ns2,Ns3),
     abdemo_nafs(Ns3,R3,R4),
     append(Gs2,Gs1,Gs3),
     abdemo(Gs3,R4,R5,Ns3,Ns4).

abdemo([G1|Gs1],R1,R4,Ns1,Ns4) :-
     choose([G1|Gs1],G2,Gs2),
     resolve(G2,R1,Gs3,R2,Ns2),
     append(Ns1,Ns2,Ns3),
     abdemo_nafs(Ns3,R2,R3),
     append(Gs3,Gs2,Gs4),
     abdemo(Gs4,R3,R4,Ns3,Ns4).

choose([G|Gs],G,Gs).

resolve(G,R,Gs,R,[]) :-
	write('resolve 1'), nl, nl,
	axiom(G,Gs).

resolve(G,R,[],R,[]) :-
	write('resolve 2'), nl, nl,
	member(G,R).

resolve(G,R,[],[G|R],[]) :-
	write('resolve 3'), nl, nl,
	abducible(G),
	consistent(G,R).

resolve(not(G),R,[],R,[[G]]) :-
	write('resolve 4'), nl, nl.

consistent(before(X,Y),R) :-
     !, X \= Y, \+ demo_before(Y,X,R,[]).
consistent(G,R).

demo_before(0,X,R,L) :- !.
demo_before(X,Y,R,L) :-
     member(before(X,Y),R), !.
demo_before(X,Y,R,L) :- member(X,L).
demo_before(X,Y,R,L) :-
     member(before(X,Z),R),
     demo_before(Z,Y,R,[X|L]).

abdemo_nafs([],R,R).
abdemo_nafs([N|Ns1],R1,R3) :-
     abdemo_naf(N,R1,R2),
     abdemo_nafs(Ns1,R2,R3).

abdemo_naf([before(X,Y)|Gs],R,R) :- X == Y, !.
abdemo_naf([before(X,Y)|Gs],R,R) :-
     demo_before(Y,X,R,[]), !.
abdemo_naf([before(X,Y)|Gs],R,[before(Y,X)|R]) :-
     \+ demo_before(X,Y,R,[]).
abdemo_naf([before(X,Y)|Gs],R1,R2) :-
     !, abdemo_naf(Gs,R1,R2).
abdemo_naf([not(G)|Gs],R,R) :-
     abdemo([G],R,R,N,N), !.
abdemo_naf([not(G)|Gs],R1,R2) :-
     !, abdemo_naf(Gs,R1,R2).
abdemo_naf([G|Gs1],R,R) :-
     \+ resolve2(G,R,Gs2,R,Ns), !.
abdemo_naf([G1|Gs1],R1,R2) :-
     findall(Gs3,
          (resolve2(G1,R1,Gs2,R1,Ns),
          append(Gs1,Gs2,Gs3)),Gss),
     abdemo_nafs(Gss,R1,R2).

resolve2(G,R,Gs,R,[]) :- axiom(G,Gs).
resolve2(G,R,[],R,[]) :- member(G,R).


/* Utilities */

skolemise(T) :- var(T), gensym(t,T), !.
skolemise(T).

gensym(Root,Atom) :-
     get_num(Root,Num), name(Root,Name1), name(Num,Name2),
     append(Name1,Name2,Name), name(Atom,Name).

get_num(Root,Num) :-
     retract(current_num(Root,Num1)), !, Num is Num1 + 1,
     asserta(current_num(Root,Num)).

get_num(Root,1) :- asserta(current_num(Root,1)).

init_gensym(Root) :- asserta(current_num(Root,1)).
